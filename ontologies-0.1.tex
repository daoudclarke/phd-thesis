 %Bismillahi-r-Rahmani-r-Rahim
 \documentclass{report}
 
 \input{head.tex}
 
 \begin{document}
 
 \chapter{Taxonomies and Vector Lattices}
 

 \section{Introduction}

Ontologies describe relationships between concepts. They are considered to be of importance in a wide range of areas within artificial intelligence and computational linguistics. For example, WordNet \cite{Fellbaum:98} is an ontology that describes relations between word senses.

Arguably the most important relation described in an ontology is the \textbf{is-a} relation (also called subsumption), which describes inclusion between classes of objects.  When applied to meanings of words, the relation is called \emph{hypernymy}. For example, a \emph{tree} is a type of \emph{plant} (the concept \emph{plant} subsumes \emph{tree}), thus the word ``plant'' is a hypernym of ``tree''. The converse relationship between words is called hyponymy, so ``tree'' is a hyponym of ``plant''. A system of classification that only deals with the \textbf{is-a} relation is referred to as a \emph{taxonomy}. An example taxonomy is shown in figure \ref{plant-taxonomy}, with the most general concept at the top, and the most specific concepts at the bottom.

The \textbf{is-a} relation is in general a partial ordering, since
\begin{itemize}
\item it is always the case that an $a$ is an $a$ (reflexivity);
\item if an $a$ is a $b$ and a $b$ is an $a$ then $a$ and $b$ are the same (anti-symmetry).
\item if an $a$ is a $b$ and a $b$ is a $c$ then an $a$ is necessarily a $c$ (transitivity).
\end{itemize}
The second of these might be argued with, but in practice this situation will not occur in most taxonomies.

In fact, we can say more than this: since most taxonomies contain a top-most node representing the most general concept (in the case of figure \ref{plant-taxonomy}, \emph{entity}), the partial ordering defines a \emph{join semilattice} (see chapter \ref{definitions}). For example, the join of the concepts \emph{rice} and \emph{beech} in figure \ref{plant-taxonomy} is \emph{plant}, the least general concept that subsumes both these concepts.\footnote{Having a top-most node is not enough to guarantee that every the structure is a semilattice, although this appears to be the case in real world taxonomies.}

Note that this definition of join does not match with the normal idea of logical disjunction of a concept. For example, if we say that something is a \emph{beech} or an \emph{oak}, it is definitely a \emph{tree}, but conversely something being a \emph{tree} does not imply that that thing is a \emph{beech} or an \emph{oak}---since it could also be a \emph{chestnut}. Thus the logical disjunction of the concepts \emph{beech} and \emph{oak} should sit somewhere between these two concepts and \emph{tree}.

We can even make the taxonomy into a lattice, by adding a new concept at the bottom, and joining this to all concepts which don't subsume any other concept (the dashed lines in figure \ref{plant-taxonomy}). The new concept can be interpreted as a ``non-existent'' or ``nonsense'' concept. The meet of any two concepts will then be given by the most general concept subsumed by the two. Interestingly, this meet does seem to correspond with logical conjunction of concepts: knowing that something is simultaneously a \emph{plant} and a \emph{grass} does not yield any new information, but claiming that something is simultaneously \emph{oak} and \emph{barley} yields the ``non-existent'' concept.

The taxonomy described by figure \ref{plant-taxonomy} has a special property: it is a tree, i.e.~no concept subsumed by one concept is subsumed by any other concept (except in the case of the artificial ``non-existent'' concept).

\begin{figure}
\begin{center}
\begin{graph}(7,7)(0,-6.6)
%\graphnodesize{0.15}
%Nodes:
\textnode{entity}(3.5,0){entity}[\graphlinecolour{1}]
\textnode{organism}(3.5,-1){organism}[\graphlinecolour{1}]
\textnode{plant}(3.5,-2){plant}[\graphlinecolour{1}]
	\textnode{grass}(2,-3){grass}[\graphlinecolour{1}]
	\textnode{cereal}(1,-4){cereal}[\graphlinecolour{1}]
		\textnode{oat}(0,-5){\rule[-0.5ex]{0pt}{2.1ex}oat}[\graphlinecolour{1}]
		\textnode{rice}(1,-5){\rule[-0.5ex]{0pt}{2.1ex}rice}[\graphlinecolour{1}]
		\textnode{barley}(2,-5){\rule[-0.5ex]{0pt}{2.1ex}barley}[\graphlinecolour{1}]
	\textnode{tree}(5,-3){tree}[\graphlinecolour{1}]
		\textnode{beech}(3.5,-4){\rule{0pt}{2ex}beech}[\graphlinecolour{1}]
		\textnode{chestnut}(5,-4){\rule{0pt}{2ex}chestnut}[\graphlinecolour{1}]
		\textnode{oak}(6.5,-4){\rule{0pt}{2ex}oak}[\graphlinecolour{1}]
\textnode{non}(3.5,-6.5){non-existent}[\graphlinecolour{1}]

%Edges:
\edge{entity}{organism}
\edge{organism}{plant}
\edge{plant}{grass}
\edge{grass}{cereal}
	\edge{cereal}{oat}
	\edge{cereal}{barley}
	\edge{cereal}{rice}
\edge{plant}{tree}
	\edge{tree}{beech}
	\edge{tree}{chestnut}
	\edge{tree}{oak}

\edge{oat}{non}[\graphlinedash{3 1}]
\edge{barley}{non}[\graphlinedash{3 1}]
\edge{rice}{non}[\graphlinedash{3 1}]
\edge{beech}{non}[\graphlinedash{3 1}]
\edge{chestnut}{non}[\graphlinedash{3 1}]
\edge{oak}{non}[\graphlinedash{3 1}]

\end{graph}
\end{center}
\caption{A small example taxonomy extracted from WordNet \citep{Fellbaum:98}.}
\label{plant-taxonomy}
\end{figure}


\section{Vector Lattice Embeddings of Taxonomies}

We now wish to examine some properties of semilattices in more detail; in 
particular we hope to show that we can describe every semilattice as 
a set of vectors. First, though, we need the following result, based 
on one in \citep{Williams:90}:

\begin{prop}[Sublattices of the Semilattice]
In a finite semilattice $L$, if $x \in L$ then $\down{x} = \{y : y 
\le x\}$ is a \emph{sub-lattice} of $L$ with the join of a subset $X$ of $\down{x}$ 
given by
$$\bigvee X = \bigwedge\{y \in \down{x} : \down{y} \supseteq X\}.$$
\end{prop}
\begin{proof}
There will always be a $y$ such that $\down{y} \supseteq X$; for 
example take $y = x$. Then clearly the above formula gives the least 
upper bound of $X$ in the sub-semilattice $\down{x}$. To see that this is also the least upper bound in $L$, consider $z \in L - \down{x}$ such that $\down{z} \supseteq X$. Then clearly $\down{z\land x} \supseteq X$, and since $x\land z \le x$, including all elements in $L$ does not change the value of the least upper bound as defined above.
\end{proof}

We will describe a way of indexing a subset of elements in a semilattice $L$ 
such that each element can be uniquely identified by two integers. 
    
\begin{defn}
    Write $x < y$ if $x \le y$ and $x \neq y$ in $L$. We say that $x$ 
    \emph{precedes} $y$ and write $x \prec y$ if $x < y$ and there is no 
    element $z$ such that $x < z < y$. Define $\pre(x)$ to be the set of 
    elements preceding $x$.%, and $\suc(x)$ (the successors of $x$) to be 
    %the set of elements which $x$ precedes.

    Elements with one or less preceding elements are called 
    \emph{increasing}; the set of increasing elements in $L$ is 
    written $\inc(L)$, i.e.
    $$\inc(L) = \{x \in L : |\pre(x)| \le 1\}$$
 
    A \emph{chain} $C_{i}$ in $\inc(L)$ is a sequence of increasing
    elements, 
    $$C_{i} = \langle x_{i,1}, x_{i,2}, \ldots x_{i,|C_{i}|}\rangle$$
     such that $x_{i,j}\le x_{i,j+1}$ for $1 \le j
    \le |C_{i}| - 1$.  Then if $\mathfrak{C} = \langle
    C_{1},C_{2},\ldots C_{n}\rangle$ is a sequence of chains such that
    $\bigcup \mathfrak{C} = \inc(L)$ and the chains in $\mathfrak{C}$
    are mutually disjoint, then each element $x_{i,j}$ in
    $\inc(L)$ is uniquely identified by it's chain $C_i$ and its position
    $j$ in that chain. In this case $\mathfrak{C}$ will be called a 
    \emph{rope} for $\inc(L)$.
\end{defn}

We will now describe how a set of vectors can be formed to represent 
a particular semilattice.

\begin{defn}
    For integer $n$, the set $[0,1]^{n}$ forms a lattice (called the
    $n$-lattice) with the meet operation $\sqcap$ defined by
    $(x_1,\ldots,x_n)\sqcap(y_1,\ldots,y_n) = (\min(x_1,y_1),\ldots,
    \min(x_n,y_n))$ i.e.~component-wise minimum and the join operation
    $\sqcup$ defined by component-wise maximum. Elements of an 
    $n$-lattice will be distinguished by a bold font (e.g.~$\mathbf{u}$) 
    and their components specified by subscript (e.g.~$u_{i}$).

    If $\mathfrak{C}$ is a rope of length $n$ for $\inc(L)$ then we define the 
    function $\mathbf{u}$ from $L$ to the $n$-lattice as follows:
$$u_k(x_{i,j})=\left\{ \begin{array}{ll}
j/|C_{i}| & \text{if }k=i\\
0 & \text{otherwise.}
\end{array}\right. $$
    Then define the function $\mathbf{v}$ from $L$ to the 
    $n$-lattice by
$$\mathbf{v}(x) = \bigsqcup\{\mathbf{u}(y) : y \in 
\down{x}\cap\inc(L)\}.$$
\end{defn}

\begin{prop}[Injective homomorphism to $n$-lattice]
For every semilattice $L$, $\mathbf{v}$ as defined above is an injective semilattice homomorphism to the $n$-lattice, i.e.~the meets in $L$ are preserved, and $\bv(x) = \bv(y)$ iff $x = y$.
\end{prop}
\begin{proof}
First we need to show that $\bv(x\land y) = \bv(x)\sqcap\bv(y)$. Clearly by definition of $\bv$, $\bv(x\land y) \sqsubseteq \bv(x)\sqcap\bv(y)$, where the partial ordering is defined by $\mathbf{s} \sqsubseteq \mathbf{t}$ iff $\mathbf{s} \sqcap \mathbf{t} = \mathbf{s}$, i.e.~$s_i \le t_i$ for $1 \le i \le n$. To see that $\bv(x\land y) \sqsupseteq \bv(x)\sqcap\bv(y)$, consider $x' \le x$ and $y' \le y$, with $x',y' \in \inc(L)$. If $x' \le y'$ then $x' \le x \land y$. Clearly if neither $x' \le y'$ nor $y' \le x'$ then $x'$ and $y'$ must be in different chains in $\mathfrak{C}$, hence either $\bu(x') \sqcap \bu(y') = 0^n$ or else either $\bu(x') \sqsubseteq \bv(x\land y)$ or $\bu(y') \sqsubseteq \bv(x\land y)$, giving the required result.

To see that $\bv$ is injective, it is enough to note that
$$x = \bigvee \down{x}\cap \inc(L),$$
that is, each element is uniquely determined by the increasing elements less than or equal to itself. Clearly this is true if $x\in \inc(L)$; otherwise $x = \bigvee \pre(x)$. Applying this recursively to elements of $\pre(x)$, we arrive at the above formula. Moreover, we need only consider the greatest element in each chain in $\down{x} \cap \inc(L)$, then the definition of $\mathbf{u}$ means that we will have a distinct value of $\mathbf{v}(x)$ for each $x$.
\end{proof}



\begin{prop}
If $L$ is a modular lattice then the semilattice homomorphism given above is also a lattice homomorphism.
\end{prop}
\begin{proof}

As is shown in \citep{Birkhoff:48}, a lattice is modular iff it does not have the following five element lattice as a sub-lattice:
\begin{center}
%\input{pentagon.tex}
\begin{graph}(4,3.5)(0,-3.25)
\graphnodesize{0.15}
%Nodes:
\roundnode{x1}(2,-0.25)
\roundnode{x2}(1,-1)
\roundnode{x3}(1,-2)
\roundnode{x4}(3,-1.5)
\roundnode{x5}(2,-2.75)
%Edges:
\edge{x1}{x2} \edge{x2}{x3} \edge{x3}{x5}
\edge{x1}{x4} \edge{x4}{x5}
\end{graph}
\end{center}
For a lattice homomorphism, we need
$$\mathbf{v}(x\lor x) = \mathbf{v}(x)\sqcup\mathbf{v}(y);$$
clearly this will be true if there is no $x'$ such that $x < x' < x\lor y$ with $x'$ in the same chain as $x$ (if this were the case, then $\mathbf{u}(x) \sqsubset\mathbf{u}(x')$ and the homomorphism will fail). This condition holds if there is no sub-lattice as above, hence $\mathbf{v}$ is a lattice homomorphism for modular lattices.
\end{proof}

%\subsection{Efficiency Considerations}

%Our representation is only useful if it provides some computational advantage either in space or time. Clearly a lattice $L$ of $m$ elements can be represented in space $m^2$ by the partial ordering relation which is a subset of $L \times L$. In fact, in \cite{freese}, it is noted that due to a theorem of Klotz and Lutz \cite{klotz}, also proved independently by Goral\v c\'\i k et al.~in \cite{goralcik}, in general we can't hope to represent lattices with better than $O(m^{3/2})$ space. The same must hold for semilattices since we can make any finite semilattice into a lattice by adding a greatest element.

%Our representation is particularly good for representing certain kinds of lattices, when we look at the lattice generated by a set of vectors. To see this, consider the semilattice generated by the vectors $\mathbf{b}^i$ for $1 \le i \le n$ in the $n$-lattice with $b^i_j = 0$ if $i = j$ and $1$ otherwise. This semilattice together with a greatest element is isomorphic to the set of subsets of a set with $n$ elements (or equivalently a Boolean algebra), and thus has $m = 2^n$ elements, however we represented it in $O(n^2)$ space, or $O((\log_2 m)^2)$ space. Presumably, then, our representation is efficient for (semi)-lattices that are similar to a Boolean algebra. The traditional (logical) view of language is that meaning is a Boolean algebra, so our representation provides an efficient way to represent generalisations of the traditional representation.

%In terms of time, we can compute meets (and joins in modular lattices) in $O(n)$ time, this compares moderately well with other representations and algorithms (see \cite{freese}).

\section{Probabilistic embeddings}

 \bibliographystyle{plainnat}
 \bibliography{contexts}
 
 \end{document}